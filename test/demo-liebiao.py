#列表就是存储多个对象的引用地址,这点和java相同,但是基本数据类型,java是常量池,而python中同样是对象引用
lst = ["hello","world"];#创建列表对象(两种方式)
lst = list(["hello","world",12,16,"longer"])
#列表的特点:列表元素有序,索引映射唯一数据,列表可以存储重复数据,任意数据类型混合,根据同台分配和回收内存
#(感觉类似java中有序可重复的Arraylist集合)从后往前取的时候是负数索引
#扩容问题??

#列表的查询操作(调用是用.的方式)
print(lst.index("hello"))#返回第一个值索引位置(不正确会抛出异常!)
print(lst.index("hello",0,1))#还可以按照range()函数中的步数的形式

#获取指定索引的元素
print(lst[0])
print(lst[-1])#还可以逆向索引

#列表元素的切片操作(默认步长依旧为1)
print(lst[1:3:2])#java中需要先建一个新的表然后调用原表的方法截取部分并且赋予引用!

#列表元素判断是否存在
print("hello" in lst)#(可以和返回索引位置结合使用,防止报错!)

#遍历列表,和遍历range()函数换汤不换药
for s in lst:
    print(s)#这里就明显的体现了不申明变量的好处了,java中因为声明了变量,因此s的类型
    # 是固定的,这也导致了一旦列表中的元素不是同一种类型就会报错,java中以泛型来避免
    # 这一问题,但是要是强行这样,就需要一个if判断结合上一个强制类型转换

#列表的增添
lst.append("asdfa")#向末尾添加一个元素
lst.extend("sadfasdf")#向末尾添加多个元素(只有一个位置哦)
lst.insert(3,"dasfafdasf")#像索引位置添加元素
lst.extend(lst[1:3])

#列表的删除
lst.remove("hello")#重复的只删除第一个(不存在时会抛出异常)
lst.pop(1)#删除索引位置的元素,若不指定索引,那么会删除最后一个元素
lst[1-3] = [];#用空来替代,也就是相当于删除列表片段(切片)
#lst.clear()#清空列表
#del lst删除元素

#列表的修改
lst[1-3]=[1,2,3,3,4]
lst[1:3]=[1,2222]#切片操作

#列表的排序
lst.sort()#调用方法
sorted(lst)#调用内置函数

#一个小问题:这里内置函数和调用方法和java中静态方法调用与实例化方法的调用是一样的吗？

#列表生成式
lst3 = [i*i for i in range(1,10)]

